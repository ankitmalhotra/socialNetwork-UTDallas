//
//  messengerViewController.m
//  socialNetwork-UTD
//
//  Created by Ankit Malhotra on 10/10/12.
//  Copyright (c) 2012 Ankit Malhotra. All rights reserved.
//

#import "messengerViewController.h"
#import "messengerAppDelegate.h"
#import <CoreLocation/CoreLocation.h>
#import "secureMessageRSA.h"
//#import <Security/Security.h>
//#import <CommonCrypto/CommonCrypto.h>
//#import <CommonCrypto/CommonDigest.h>



/*static variable declaration*/

/*Flag to ensure initial login view is displayed only once*/
static int appearCheck=0;
/*Flag to tell message posts are fetched and ready to be shown in text view*/
static int showPosts=0;
/*Mutable Array object to collate group names inbound from server*/
static NSMutableArray *groups;
/*Mutable Array object to collate friend names inbound from server*/
static NSMutableArray *friends;
/*Stores the userId (NOT user name)*/
static NSString *username;
/*Stores the userNumber (an Integer number unique for every user, generated by server)*/
static NSString *userNumber;
/*Stores the user's password*/
static NSString *userpwd;
/*Stores the user's emailID*/
static NSString *userMailID=NULL;
/*Stores the selected group name from group table view*/
static NSString *grpname;
/*Stores the selected friend name from friend table view*/
static NSString *friendname;
/*Mutable Array object to collate message post data from server*/
static NSMutableArray *messagePostData;
/*String to show message data in text view*/
static NSMutableArray *messageDataToShow;
/*String to show username data in text view*/
static NSMutableArray *userNameDataToShow;
/*Mutable Array object to collate friend's user number from post data*/
static NSMutableArray *friendNumber;
/*Mutable Array object to collate friend's user name from post data*/
static NSMutableArray *friendName;
/*Stores location latitude*/
static double locationLatitude;
/*Stores location latitude*/
static double locationLongitude;

/*Geo-location vars*/
static NSString *streetAddress;
static NSString *city;
static NSString *state;
static NSString *zip;


@interface messengerViewController ()
{
    /*Location constants*/
    CLLocationManager *locManager;
}

@end


@implementation messengerViewController


- (void)viewDidLoad
{
    NSLog(@"val is: %d",appearCheck);
    
    /*Object instantiations*/
    groups=[[NSMutableArray alloc]init];
    friends=[[NSMutableArray alloc]init];
    messagePostData=[[NSMutableArray alloc]init];
    restObj=[[messengerRESTclient alloc]init];
    groupViewObj=[[groupsTableViewViewController alloc]init];
    newPostObj=[[newPostViewController alloc]init];
    detailMsgViewObj=[[detailMessageViewController alloc]init];
    
    UIImageView *bg = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"tattered_resized.jpg"]];
    [postsViewer setBackgroundView:bg];
    
    navBar=[[UINavigationBar alloc]init];
    [super viewDidLoad];

    /*Start Location updater everytime view loads up*/
    [self initLocUpdate];
    
    /*Add a refresh controller to the table view*/
    refreshControl=[[UIRefreshControl alloc]init];
    [refreshControl addTarget:self action:@selector(refreshTableView) forControlEvents:UIControlEventValueChanged];
    [postsViewer addSubview:refreshControl];
    
    connProgress.transform=CGAffineTransformMakeScale(1.5, 1.5);
    /*Set the label to display the logged-in user's ID
    UILabel *userIdLabel=[[UILabel alloc]initWithFrame:CGRectMake(130, 42, 120, 30)];
    NSString *welcomeMsg=username;
    welcomeMsg=[welcomeMsg stringByAppendingString:@", Hello !"];
    userIdLabel.text=welcomeMsg;
    userIdLabel.numberOfLines=3;
    userIdLabel.backgroundColor=[UIColor clearColor];
    userIdLabel.textColor=[UIColor whiteColor];
    userIdLabel.font=[UIFont systemFontOfSize:18.0];
    [self.view addSubview: userIdLabel];
     */
}

-(void)initLocUpdate
{
    /*Setup Location Manager & start updating location*/
    locManager=[[CLLocationManager alloc] init];
    locManager.delegate=self;
    locManager.desiredAccuracy=kCLLocationAccuracyBest;
    locManager.distanceFilter=0.0f;
    if([CLLocationManager locationServicesEnabled])
    {
        [locManager startUpdatingLocation];
    }
}

-(void)refreshTableView
{
    if(grpname!=NULL)
    {
       [self showPostData:grpname];   
    }
    [postsViewer reloadData];
    [refreshControl endRefreshing];
    /*
    double delayInSeconds = 1.0;
    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
        [refreshControl endRefreshing];
    });
     */
}

-(void)viewDidAppear:(BOOL)animated
{
    /*load up login view*/
    NSLog(@"check_flag: %d",appearCheck);
    if(appearCheck==0)
    {
        appearCheck=1;
        loginViewController *loginVw=[[loginViewController alloc]initWithNibName:nil bundle:nil];
        [self presentViewController:loginVw animated:YES completion:NULL];
        [loginVw release];
    }
    else
    {
    }
}


-(void)viewWillAppear:(BOOL)animated
{
    if(appearCheck!=0)
    {
        /*Reload the table with newly generated posts*/
        if(grpname!=NULL)
        {
            [self showPostData:grpname];
        }
        double delayInSeconds = 0.5;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
        dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
            [postsViewer reloadData];
        });
    }
}

/*Define group values to be shown in group tableview*/
-(NSMutableArray *)getGroupObjects :(NSMutableArray *)arrayInput :(int)toReturn
{
    /*If toReturn is 1: collate the data inbound into groups object*/
    if(toReturn==1)
    {
        [groups addObjectsFromArray:arrayInput];
        NSLog(@"group data received: %@",groups);
        return NULL;
    }
    /*If toReturn is 0: return the collated data to show in table*/
    else
    {
        NSLog(@"showing group data: %@",groups);
        return groups;
    }
}

/*Define friend values to be shown in friend tableview*/
-(NSArray *)getFriendObjects :(NSMutableArray *)arrayInput :(int)toReturn
{
    /*If toReturn is 1: collate the data inbound into friends object*/
    if(toReturn==1)
    {
    
        [friends addObjectsFromArray:arrayInput];
        NSLog(@"friend data received: %@",friends);
        return NULL;
    }
    /*If toReturn is 0: return the collated data to show in table*/
    else
    {
        NSLog(@"showing friend data: %@",friendName);
        return friendName;
    }
}


/*Receive the index selected in group tableview*/
-(void)setSelectedIndex:(NSString *)indexVal
{
    grpname=[indexVal retain];
    NSLog(@"index selected: %@",grpname);
    [navBar.topItem setTitle:grpname];
    [self showPostData:grpname];
}

/*Receive the index selected in friends tableview*/
-(void)setSelectedIndexFriends: (NSString *)indexVal
{
    friendname=[indexVal retain];
    NSLog(@"friend index selected: %@",friendname);
}

-(NSString *)signalGroupName
{
    NSLog(@"group sending: %@",grpname);
    return grpname;
}

/*Signal collated friends data*/
-(NSMutableArray *)signalFriends
{
    NSLog(@"friend sending: %@",friends);
    return friends;
}

-(void)storeUserNumber:(NSMutableArray *)userNum
{
    NSLog(@"user number chk: %@",userNum);
    if([userNum containsObject:@"true"])
    {
        [userNum removeObject:@"true"];
    }
    if([userNum containsObject:@"false"])
    {
        [userNum removeObject:@"false"];
    }
    
    if([userNum count]>0)
    {
        userNumber=[userNum objectAtIndex:0];
        NSLog(@"user number received: %@",userNumber);
        /*Send user number to groups table view controller*/
        groupViewObj=[[groupsTableViewViewController alloc]init];
        [groupViewObj getUserNumber:userNumber];
        
        userChatObj=[[userChatViewController alloc]init];
        [userChatObj getUserNumber:userNumber];
        [userChatObj getUserId:username];
    }
    
}

-(void)showPostData:(NSString *)groupName
{
    restObj=[[messengerRESTclient alloc]init];
    dispatch_async(dispatch_get_main_queue(), ^{
        [restObj showPostData:groupName :@"getGroupMessages"];
        retVal=[restObj returnValue];
        if(retVal==1)
        {
            int k=0;
            messageDataToShow=NULL;
            userNameDataToShow=NULL;
            NSLog(@"messages data count: %d",[messagePostData count]);
            NSLog(@"number of messages: %u",[messagePostData count]/2);
            
            while(k<[messagePostData count] && [messagePostData count]!=1 && [messagePostData count]%2==0)
            {
                k++;
                messageDataToShow=[messagePostData objectAtIndex:k];
                userNameDataToShow=[messagePostData objectAtIndex:k-1];
                k++;
                showPosts=1;
            }
            [self clearAllPosts];
        }
        else if(retVal==-1)
        {
            UIAlertView *msgListAlert=[[UIAlertView alloc]initWithTitle:@"Failed" message:[NSString stringWithFormat:@"Message list could not be retrieved. Please try again"] delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
            [msgListAlert show];
            [msgListAlert release];
        }
        else if(retVal==0)
        {
            NSLog(@"retval is: %d",retVal);
            UIAlertView *connNullAlert=[[UIAlertView alloc]initWithTitle:@"Connection Error" message:@"Unable to contact server" delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil];
            [connNullAlert show];
            [connNullAlert release];
        }
    });
}


-(void)collectedPostData:(NSMutableArray *)inputArray
{
    [messagePostData addObjectsFromArray:[inputArray retain]];
    [messagePostData retain];
}

/*Setting the username received from loginView*/
-(void)getUserId:(NSString *)userId :(NSString *)userPassword
{
    userpwd=[[NSString alloc]init];
    username=[[NSString alloc]init];
    username=[userId retain];
    //userpwd=[userPassword retain];
    
    /*Signal userId to groupsTableView(to be used for new group creation*/
    
    groupViewObj=[[groupsTableViewViewController alloc]init];
    [groupViewObj getUserData:username :userpwd :userMailID];
    
    /*Signal userId to newPostView(to be used for new post creation*/
    newPostObj=[[newPostViewController alloc]init];
    [newPostObj getUserId:username];
}

/*Setting the userEmailID received from signupview*/
-(void)getUserMailID:(NSString *)mailID
{
    userMailID=[mailID retain];
}



/*Location update function calls*/

-(void) locationManager:(CLLocationManager*)locManager
    didUpdateToLocation:(CLLocation*)newLocation
           fromLocation:(CLLocation*)oldLocation
{
    NSDate* eventDate = newLocation.timestamp;
    NSTimeInterval howRecent = [eventDate timeIntervalSinceNow];
    if (abs(howRecent) < 100000.0)
    {
        NSString *showPos=[NSString stringWithFormat:@"lat: %f,long: %f",newLocation.coordinate.latitude,newLocation.coordinate.longitude ];
        double latPos=newLocation.coordinate.latitude;
        double longPos=newLocation.coordinate.longitude;
        locationLatitude=latPos;
        locationLongitude=longPos;
        NSLog(@"Current user position: %@",showPos);
        
        /*Signal location co-ords to groupsTableView(to be used for new group creation)*/
        [groupViewObj getLocationCoords:latPos :longPos];
        
        /*Signal location co-ords to groupsTableView(to be used for posting messages to groups)*/
        [newPostObj getLocationCoords:latPos :longPos];
        
        /*
        typedef double CLLocationDistance;
        CLLocationDistance dist = [oldLocation distanceFromLocation:newLocation];
        NSLog(@"distance moved: %f meters",(dist));
        NSString *distmoved=[NSString stringWithFormat:@"You just moved: %f meters",(dist)];
        */
        
        /*Reverse Geo-coding*/
        NSOperationQueue *geoLocQueue=[NSOperationQueue new];
        SEL methodSelector=@selector(getGeoCoords::);
        NSMethodSignature *methodSignature=[self methodSignatureForSelector:methodSelector];
        NSInvocation *methodInvocation=[NSInvocation invocationWithMethodSignature:methodSignature];
        [methodInvocation setTarget:self];
        [methodInvocation setSelector:methodSelector];
        
        [methodInvocation setArgument:&latPos atIndex:2];
        [methodInvocation setArgument:&longPos atIndex:3];
        [methodInvocation retainArguments];
        
        NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithInvocation:methodInvocation];
        [geoLocQueue addOperation:invocationOperation];
        
        [invocationOperation release];
        [geoLocQueue release];
        
        /*Stop location updates*/
        [self stopUpdate];
    }
}

/*This method extracts reverse geocoding information from a given coordinate position on earth*/
-(void)getGeoCoords:(double)latitude :(double)longitude
{
    CLGeocoder *geoCoder=[[CLGeocoder alloc]init];
    CLLocation *currentLocation=[[CLLocation alloc]initWithLatitude:latitude longitude:longitude];
    
    [geoCoder reverseGeocodeLocation:currentLocation completionHandler:^(NSArray *placeMarks, NSError *err){
            if(err)
            {
                NSLog(@"Reverse geo-coding failed !");
                return;
            }
            if(placeMarks && placeMarks.count>0)
            {
                CLPlacemark *placeMarkers=placeMarks[0];
                NSDictionary *locationDictionary=placeMarkers.addressDictionary;
                
                streetAddress=[locationDictionary objectForKey:(NSString *)kABPersonAddressStreetKey];
                city=[locationDictionary objectForKey:(NSString *)kABPersonAddressCityKey];
                state=[locationDictionary objectForKey:(NSString *)kABPersonAddressStateKey];
                zip=[locationDictionary objectForKey:(NSString *)kABPersonAddressZIPKey];
                
                NSLog(@"logged in from:");
                NSLog(@"street: %@",streetAddress);
                NSLog(@"city: %@",city);
                NSLog(@"state: %@",state);
                NSLog(@"zip: %@",zip);
            }
    }];
}

-(BOOL)shouldAutorotate
{
    return NO;
}

/*Clear the group list mutable array object(groups) when group tableview is dismissed*/
-(void)clearBufferList
{
    [groups removeAllObjects];
    [friends removeAllObjects];
}

/*Clear all the posts before reloading table view*/
-(void)clearAllPosts
{
    [messagePostData removeAllObjects];
}

/*Show groups listing*/
-(IBAction)showGroups
{
    groupsBtn.enabled=FALSE;
    friendsBtn.enabled=FALSE;
    postBtn.enabled=FALSE;
    connProgress.hidden=FALSE;
    [connProgress startAnimating];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [restObj sendMessage:username :nil :nil :nil :nil :@"listMemberGroups"];
        retVal=[restObj returnValue];
        if(retVal==1)
        {
            groupsBtn.enabled=TRUE;
            friendsBtn.enabled=TRUE;
            postBtn.enabled=TRUE;
            connProgress.hidden=TRUE;
            [connProgress stopAnimating];
            
            groupsTableViewViewController *gTblView=[[groupsTableViewViewController alloc]initWithNibName:nil bundle:nil];
            [self presentViewController:gTblView animated:YES completion:NULL];
            [gTblView release];
        }
        else
        {
            groupsBtn.enabled=TRUE;
            friendsBtn.enabled=TRUE;
            postBtn.enabled=TRUE;
            connProgress.hidden=TRUE;
            [connProgress stopAnimating];
            
            UIAlertView *connErr=[[UIAlertView alloc]initWithTitle:@"Connection Error" message:@"Unable to contact server" delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil];
            [connErr show];
            [connErr release];
        }
    });
    
}

/*show friends listing */
-(IBAction)showFriends
{
    groupsBtn.enabled=FALSE;
    friendsBtn.enabled=FALSE;
    postBtn.enabled=FALSE;
    connProgress.hidden=FALSE;
    [connProgress startAnimating];
    
    NSLog(@"passing for user: %@ and group; %@",username,grpname);
    dispatch_async(dispatch_get_main_queue(), ^{
        [restObj getFriendList:username :grpname :locationLatitude :locationLongitude :@"getUsersInGroup" ];
        double delayInSeconds = 1.3;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
        dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
            retVal=[restObj returnValue];
            if(retVal==1)
            {
                /*Bifurcate the friend names and their user numbers. User numbers would be used for chatting amongst each other*/
                friendName=[[NSMutableArray alloc]init];
                friendNumber=[[NSMutableArray alloc]init];
                for(int k=0;k<[friends count];k++)
                {
                    [friendNumber addObject:[friends objectAtIndex:k]];
                    [friendName addObject:[friends objectAtIndex:k+1]];
                    k++;
                }
                
                friendObj=[[friendsViewController alloc]init];
                [friendObj getFriendNumbers:friendNumber];
                
                groupsBtn.enabled=TRUE;
                friendsBtn.enabled=TRUE;
                postBtn.enabled=TRUE;
                connProgress.hidden=TRUE;
                [connProgress stopAnimating];
                
                friendsViewController *fTblView=[[friendsViewController alloc]initWithNibName:nil bundle:nil];
                [self presentViewController:fTblView animated:YES completion:NULL];
                [fTblView release];
            }
            else
            {
                groupsBtn.enabled=TRUE;
                friendsBtn.enabled=TRUE;
                postBtn.enabled=TRUE;
                connProgress.hidden=TRUE;
                [connProgress stopAnimating];
                
                UIAlertView *connErr=[[UIAlertView alloc]initWithTitle:@"Connection Error" message:@"Unable to contact server" delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil];
                [connErr show];
                [connErr release];
            }
        });
    });
}

/*load view for new post*/
-(void)createPost
{
    newPostViewController *newPostView=[[newPostViewController alloc]initWithNibName:nil bundle:nil];
    [self presentViewController:newPostView animated:YES completion:NULL];
    [newPostView release];
}

-(void)stopUpdate
{
    [locManager stopUpdatingLocation];
    NSLog(@"Location updater stoppped.");
}

#pragma mark - Table view data source
/*
 - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
 {
    return [arr count];
 }
*/

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    NSLog(@"delegate called..");
    
    if(messagePostData==NULL)
    {
        return 0;
    }
    else
    {
        return [messagePostData count]/2;
    }
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier = @"PostsCell";
    
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier] autorelease];
    }
    
    if (messageDataToShow!=NULL && userNameDataToShow!=NULL)
    {
        /*This block seperates out username and his post and assigns username to cell's detail text label & post to cell's text label*/
        int forUser=[indexPath row];
        if(forUser<[messagePostData count]/2)
        {
            forUser+=forUser;
            cell.textLabel.text=[messagePostData objectAtIndex:forUser+1];
            /*Build the string to be displayed in cell's detail text label*/
            cellDetailTextLabel=[[NSString alloc]initWithString:[messagePostData objectAtIndex:forUser]];
            cellDetailTextLabel=[cellDetailTextLabel stringByAppendingString:@" near "];
            //cellDetailTextLabel=[cellDetailTextLabel stringByAppendingString:city];
            cellDetailTextLabel=[cellDetailTextLabel stringByAppendingString:@", "];
            //cellDetailTextLabel=[cellDetailTextLabel stringByAppendingString:state];
            
            cell.detailTextLabel.text=cellDetailTextLabel;
            cell.detailTextLabel.textColor=[UIColor whiteColor];
        }
        else
        {
            NSLog(@"rendering averted");
        }
        
    }
    return cell;
}

#pragma mark - Table view delegate

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
	[tableView deselectRowAtIndexPath:indexPath animated:YES];
    UITableViewCell *selectedCell=[tableView cellForRowAtIndexPath:indexPath];
    
    selectedPost=selectedCell.textLabel.text;
    NSLog(@"you selected: %@",selectedPost);
    [detailMsgViewObj getPostMessageToDisplay:selectedPost];
    
    [self presentViewController:detailMsgViewObj animated:YES completion:nil];
}


- (void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];
}

@end